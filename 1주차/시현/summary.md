# 1주차

✳️ **4장 변수**

4-1. 변수란 무엇인가? 왜 필요한가?

- **변수의 필요성**

애플리케이션은 **데이터**를 입력받아 처리한다.

이 데이터를 어떻게 기억 할 것인가? → **메모리**

![Untitled](https://github.com/ksihyeon/test-app/assets/45176736/a6d7be0f-6f95-4e8d-bcb1-10c75bdd165c)


메모리에 저장한 값을 다시 불러오려면 어떻게 해야 할까? → **메모리 주소**

하지만, 메모리 주소를 통해 값을 저장하고 참조할 수 없다. → Javascript 는 개발자의 직접적인 메모리 제어를 허용하지 않으며,  메모리 주소는 임의로 결정 및 변경되므로 메모리 주소를 통해 값에 직접 접근할 수 없다.

- 매니지드, 언매지니드 언어

프로그래밍 언어는 메모리 관리 방식에 다라 매니지드, 언매니지드 언어로 나눌 수 있다. 언매니지드 언어는 개발자가 명시적으로 메모리를 할당하고, 해제하기 위해 `malloc()`, `free()` 같은 저수준 메모리 제어 기능을 제공한다. 언매니지드 언어는 메모리 제어를 개발자가 주도할 수 있으므로 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만, 그 반대의 경우 치명적 오류를 발생시킬 수 있다.

따라서, 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 **변수**라는 메커니즘을 제공한다. 

**변수**는 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다.

- **변수**

```jsx
let num = 1;
```

- 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위한 이름
- 변수 값 : 변수에 저장된 값
- 할당 : 변수에 값을 저장하는 것
- 참조 : 변수에 저장된 값을 읽어 들이는 것

```jsx
var use = {id:1, name:'Lee'};
```

배열이나 객체 같은 자료구조를 사용하면 관련이 있는 여러 개의 값을 그룹화해서 하나의 값처럼 사용할 수 있다.

4-2. 식별자

- 변수 이름 = 식별자
    - 어떤 값을 구별해서 식별할 수 있는 고유한 이름
    - 값이 아니라 메모리 주소를 기억하고 있다.

4-3. 변수 선언

변수를 생성하는 것 : 변수 선언

`var`, `let`, `const`

```jsx
var sum;
```

4-4. 변수 선언의 실행 시점과 변수 호이스팅

자바스크립트 엔진은 모든 선언문을 소스코드에서 찾아내 먼저 실행한다. (런타임 전 단계)

- 변수 호이스팅 : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

- ➕  let, const 는 호이스팅 되지 않는 것인가?
    
    `let/const`선언 변수는 호이스팅되지 않는 것이 아니다. 스코프에 진입할 때 변수가 만들어지고 TDZ(Temporal Dead Zone)가 생성되지만, 코드 실행이 변수가 실제 있는 위치에 도달할 때까지 액세스할 수 없는 것이다. `let/const`변수가 선언된 시점에서 제어흐름은 `TDZ`를 떠난 상태가 되며, 변수를 사용할 수 있게 된다.
    
    ![Untitled 1](https://github.com/ksihyeon/test-app/assets/45176736/cadf5782-4c87-4bea-aa4d-924754983c76)
    
    ```jsx
    var x = 'outer scope';
    (function() {
      console.log(x); // undefined
      var x = 'inner scope';
    }());
    ```
    
    `var` 와 `let/const` 선언에 대한 범위의 차이 중 하나는 `let/const` 가 `TDZ` 에 의해 제약을 받는다는 것이다.
    
    즉, 변수가 초기화되기 전에 액세스하려고 하면, `var` 처럼 `undefined` 를 반환하지 않고, ReferenceError 가 발생한다. 이는 코드를 예측가능하고 잠재적 버그를 쉽게 찾아낼 수 있도록 한다.
    
    ![Untitled 2](https://github.com/ksihyeon/test-app/assets/45176736/b23ef724-6c48-4069-90c1-da00a3994110)
    
    ```jsx
    const x = 'outer scope';
    (function() {
      console.log(x); // ReferenceError 
      const x = 'inner scope';
    }());
    ```
    

4-5. 값의 할당

변수에 값을 할당할 때는 =(대입연산자)를 사용한다.

```jsx
var score = 80;

// 위의 코드는 실제로 다음과 같다.
var score; // 선언과 동시에 undefined 할당
score = 80;
```

4-6. 값의 재할당

```jsx
var score = 80;
score = 90;
```

![Untitled 3](https://github.com/ksihyeon/test-app/assets/45176736/c98ae58c-7c18-453f-a410-2ce83f2d893d)

불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다. 
→ (JavaScript 엔진 - JavaScript를 해석하고 실행 내부적으로 메모리 관리를 수행)

`var`키워드로 선언한 변수는 선언과 동시에 `undefined`가 할당되고, 그 뒤에 값이 들어가는 것이기 때문에 엄밀히 따지면 재할당에 해당한다.

재할당은 변수에 저장된 값을 다른 값로 변경한다. 만약 값을 재할당 할 수 없으면? → 변경할 수 없다면 그 값을 상수`const`라고 한다.

4-7. 식별자 네이밍 규칙

예약어는 식별자로 사용할 수 없다. (`await`, `break`, `case`…)

- 네이밍 컨벤션
    
    하나 이상의 영어 단어로 구성된 식별자를 가독성있게 보기쓰기 명명규칙
    
    - `var firstName` 카멜 케이스
        - 변수나 함수의 이름
    - `var FirstName` 퍼스칼 케이스 
        - 생성자, 함수 클래스의 이름

✳️ 5장 표현식과 문

5-1. 값

식(표현식)이 평가되어 생성된 결과

```jsx
var sum = 10 + 20; // 30
```

5-2. 리터럴

사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

정수 리터럴, 부동소수점 리터럴, 문자열 리터럴, 불리언 리터럴 …

사람이 이해할 수 있는 숫자 코드에 기술 (ex. `3`)

→ 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성 

```jsx
var isRunning;
console.log(typeof(isRunning)); // undefined

var isRunning = true; // boolean 리터럴로 변수 초기화
console.log(typeof(isRunning)); // boolean
```

5-3. 표현식

표현식은 값으로 평가될 수 있는 문이다. 즉 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
표현식은 평가되어 값을 생성하므로, 표현식은 값처럼 사용할 수 있다.

```jsx
var x = 1 + 2;
x + 3;
```

5-4. 문

프로그램을 구성하는 기본 단위이자, 최소 실행 단위

```jsx
// var, x, 1, +, 2,; 
// 각각이 토큰이며, 하나의 문은 여러 토큰으로 구성된다.
```

5-5. 세미콜론과 세미콜론 자동 삽입 기능

세미콜론 : 문의 종료

`{…}` 코드 블록 뒤에는 일반적으로 세미콜론을 붙이지 않는다.

- ➕ 객체를 선언한 중괄호 `{ };`
    
    반면 객체를 선언한 중괄호 뒤에는 세미콜론을 붙인다. 
    
    이는 코드 블록이 아니라 객체의 값을 표현하는 리터럴 방식이기 때문이다.
    
    ```jsx
    let person = {
    name : michael,
    age: 10
    };
    ```
    

자바스크립트 엔진이 문의 끝이라고 예측되는 지점에 `세미콜론 자동 삽입 기능` 을 암묵적으로 수행

5-6. 표현식인 문과 표현식이 아닌 문

값으로 평가될 수 있는 문인지로 구분할 수 있다. → **변수에 할당**해 봄으로써 구분

```jsx
var foo = var x; (X)

var foo = x = 100; (O)
```

✳️ 6장 데이터 타입

원시타입, 객체 타입

| 원시타입 | 숫자, 문자열, 불리언, undefined, null, 심벌 |
| --- | --- |
| 객체타입 | 객체, 함수, 배열 등 |

6-1. 숫자 타입

자바스크립트는 하나의 숫자 타입, `number`만 존재한다.
모든 수를 **실수**로 처리. 정수만 표현하기 위한 데이터 타입이 존재하지 않음.

- 추가로 표현할 수 있는 것
    - `Infinity` ex) `10 / 0`
    - `Infinity` ex) `10 / -0`
    - `NaN` : 산술 연산 불가(not-a-number) ex) `1 / 'String'`

6-2. 문자열 타입

가장 일반적인 표기법으로 작은따옴표`' '`를 사용

6-3. 템플릿 리터럴

ES6부터 도입된 새로운 문자열 표기법. 백틱(\`\`)을 사용해 표현하는 방식이다.
멀티라인 문자열, 표현식 삽입 등 편리한 문자열 처리 가능

- 멀티라인 문자열

```jsx
var template = `<ul>
	<li><a href="#">Home</a></li>
<ul>`;
```

- 표현식 삽입

```jsx
var numA = 1;
var numB = 2;
console.log(`${numA} + ${numB} = ${numA + numB}`); // 1 + 2 = 3
```

6-4. 불리언 타입

`true`, `false`

6-5. undefined 타입

`var` 키워드로 선언한 변수일 때, 암묵적으로 `undefined`로 초기화 된다.

할당하기 위한 값이 아닌 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이므로

의도적으로 `undefined`를 할당하는 것은 권장하지 않는다.

6-6. null 타입

`null`은 변수에 '값이 없다'는 것을 의도적으로 명시할 때 사용한다.

변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미로, 할당되어 있던 값에 대한 참조를 제거하게 되며, 자바스크립트 엔진이 가비지 콜렉션을 수행한다.

- 함수가 유효한 값을 반환할 수 없는 경우 `null`을 반환하기도 한다.

6-7. 심벌 타입

다른 값과 중복되지 않는 유일무이한 값을 말한다.

ES6에서 추가된 7번째 타입으로, 원시 타입이다.

다른 원시 타입들은 리터럴을 통해 생성하지만 심벌은 `Symbol`함수를 호출해 생성한다.

```jsx
var keyA = Symbol('key');
var keyB = Symbol('key');
console.log(typeof keyA); // Symbol

//객체 생성
var obj = {};

obj[keyA] = 'valueA';
obj[keyB] = 'valueB';
console.log(obj[keyA]); // valueA
console.log(obj[keyB]); // valueB
```

6-8. 객체 타입

`Object` 는 객체 타입으로 원시형 타입과 다르게 객체형은 다양한 데이터를 담을 수가 있다.

6-9. 데이터 타입의 필요성

데이터 타입이 존재하므로 메모리에 **정해진 크기의 공간을 확보**할 수 있고, **이에 따라 참조**할 수 있다.

- 값을 지정할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위하여
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위하여
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위하여

6-10. 동적 타이핑

- 정적 타입 언어

변수를 선언할 때 해당 변수에 할당할 수 있는 데이터 타입을 사전에 선언해야 한다.

```cpp
int num = 0;
char* pszText = "Text";
```

- 동적 타입 언어

변수를 선언할 때 타입을 선언하지 않는다.

변수에 할당된 값의 데이터 타입을 반환한다.

```cpp
var foo;
console.log(typeof foo); // undefined;

foo = 3;
console.log(typeof foo); // number

foo = 'hello';
console.log(typeof foo); // string

foo = true;
console.log(typeof foo); // booean
```

변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있으나, 복잡한 프로그램 안에서 변수의 값은 빈번히 변하게 되고, 동적 타입 언어는 변수에 어떤 값이 할당 되냐에 따라서 데이터 타입이 변하기까지 한다.

- 변수 사용 시, 고려할 점
    - 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.
    - 변수의 스코프를 최대한 좁게 만들어야 한다.
    - 전역 변수는 최대한 사용하지 않는다.
    - 변수보다는 최대한 상수를 사용한다.
    - 의미있는 변수 네이밍이 필요하다.

- ➕ typescript
    
    자바스크립트의 슈퍼셋인 오픈소스 프로그래밍 언어이다. 마이크로소프트에서 개발, 유지하고 있으며 엄격한 문법을 지원한다.
    
    ```tsx
    interface CodeName {
      code: string;
      name: string;
    }
    ```
