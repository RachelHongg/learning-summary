# 10장 객체 리터럴

## 객체란?

- 자바스크립트는 객체 기반 프로그래밍 언어, 원시 값을 제외한 모든 것이 객체
  - 객체 기반 프로그래밍 : 객체의 집합으로 프로그램을 표현하려는 패러다임
- 객체는 프로퍼티와 메서드로 구성되어 있다.
  - 프로퍼티 : 객체의 상태를 나타내는 값
  - 메서드 : 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

## 객체 리터럴에 의한 객체 생성

- 자바스크립트는 프로토타입 기반 객체지향 언어로 다양한 객체 생성 방법이 있다.
  - 객체 리터럴
  - Object 생성자 함수
  - 생성자 함수
  - Object.create 메서드
  - 클래스(ES6)
- 가장 간단한 방법은 객체 리터럴를 사용한다.
  - 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법
  - 중괄호({...})내에 0개 이상의 프로퍼티를 정의, 변수에 할당 되는 시점에 자바스크립트 엔진은 객체 리터럴을 해석해 객체를 생성한다.
  - 중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.
  - 코드 블록이 아니므로 끝에 세미콜론(;)을 붙인다.

## 프로퍼티

- 객체는 프로피터의 집합, 프로퍼티는 키와 값으로 구성된다.
  ```javascript
  var person = {
     // 프로퍼티는 name, 프로퍼티 값은 Lee
     name : 'Lee';
     age : 20
  };
  ```
- 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심벌 값

  - 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 붙여야한다.
    ```javascript
    var person = {
      firstName: "Ung-mo", // 식별자 네이밍 규칙을 따르며 따옴표 생략 가능
      "last-name": "Lee",
      // 식별자 네이밍 규칙을 준수하지 않으며 따옴표 생략 불가(-를 연산자가 있는 표현식으로 해석)
    };
    ```
  - 문자열 or 문자열로 평가할 수 있는 표현식을 사용해 동적으로 프로퍼티 키를 생성 가능하지만 키로서의 의미를 가지지 못하므로 권장하지 않는다.

    ```javascript
    var obj = {};
    var key = "hello";

    // ES5: 프로퍼티 키 동적 생성
    obj[key] = "world";
    // ES6: 계산된 프로퍼티 이름
    // var obj = { [key]: 'world; };

    console.log(obj); // {hello: "world"}
    ```

  - 빈 문자열, 예약어로도 프로퍼티 키로 사용이 가능하지만 에러 발생 소지가 있으므로 권장하지 않는다.
  - 문자열이나 심벌 값 외의 값을 사용하면 암묵적 타입으로 문자열이 된다.
  - 이미 존재하는 프로퍼티 키를 중복 선언하면 먼저 선언된 프로퍼티 키에 덮어써지므로 조심해야한다.

- 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값

## 메서드

- 프로퍼티 값으로는 모든 값을 사용하기 때문에 함수 또한 사용 가능하다.
- 이때 일반 함수와 구분하기 위해 프로퍼티 값이 함수일 경우 메서드라고 부른다.

  ```javascript
  var circle = {
    radius: 5, // <- 프로퍼티

    getDiameter: function () {
      return 2 * this.radius; // this는 circle을 가리킨다.
    },
  };

  console.log(circle.getDiameter()); // 10
  ```

## 프로퍼티 접근

- 마침표 프로퍼티 접근연산자(.)를 사용하는 마침표 표기법
- 대괄포 프로퍼티 접근연산자([...])를 사용하는 대괄호 표기법

- 접근연산자 좌측에 객체로 평가되는 표현식을 기술한다.
- 마침표 접근연산자 우측이나 대괄호 접근연산자 내부에는 프로퍼티 키를 지정한다.

  ```javascript
  var person = {
    name: "Lee",
  };

  console.log(person.name); // Lee
  console.log(person["name"]); // Lee
  ```

  - 대괄호 접근연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 표기해야한다.

- 객체에 존재하지 않는 프로퍼티에 접근 시 undefined를 반환한다.
- 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름이면 반드시 대괄호 표기법을 사용해야한다. ex) 숫자
- 대괄호 표기법에서 프로퍼티 키가 숫자라면 따옴표를 생략할 수 있다.

  ```javascript
  var person = {
    name: "Lee",
    1: 10
  };

  person.'last-name'; // SyntaxError: Unexpected string
  person.last-name;
  // 브라우저 환경 : NaN, Node.js 환경 : ReferenceError : name is not defined
  // 자바스크립트 엔진은 person.last를 먼저 평가해 undefined 반환, undefined-name과 같다.
  // Node.js는 name이라는 식별자가 없으므로 ReferenceError : name is not defined 반환
  // 브라우저는 name이라는 창(window)를 가리키는 전역변수가 존재해 undefined-''과 같아 NaN 반환

  person[last-name]; // ReferenceError : name is not defined
  person['last-name']; // Lee

  person.1; // SyntaxError: Unexpected number
  person.'1'; // SyntaxError: Unexpected string
  person[1]; // 10 실질적으로 문자열
  person['1']; // 10
  ```

## 프로퍼티 값 갱신

- 이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.

## 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 값이 할당된다.

## 프로퍼티 삭제

- delete 연산자는 객체의 프로퍼티를 삭제한다.

  - 만약 존재하지 않는 프로퍼티를 삭제하면 에러 없이 무시된다.

  ```javascript
  var person = {
    name: "Lee",
  };

  person.name = "Kim"; // {name : 'Kim'}
  person.age = 20; // {name: 'Kim', age: 20}
  delete person.age; // person의 age가 삭제 됨
  delete person.address; // 삭제 불가능, 에러 발생 X
  ```

## ES6에서 추가된 객체 리터럴의 확장 기능

- 프로퍼티 축약 표현

  - 프로퍼티 값을 변수에 할당된 값으로도 가능하다.
  - 프로퍼티 값으로 변수를 사용할 때 이름과 키가 동일하다면 키를 생략 가능하다.

    - 프로퍼티 키는 변수명으로 자동 생성된다.

    ```javascript
    var x = 1,
      y = 2;

    var obj = {
      x: x,
      y: y,
    };

    console.log(obj); // {x: 1, y: 2}
    // 프로퍼티 값을 변수에 할당된 값으로도 가능하다.

    let x = 1,
      y = 2;

    const obj = { x, y };
    console.log(obj); // {x: 1, y: 2}
    // 프로퍼티 값으로 변수를 사용할 때 이름과 키가 동일하다면 키를 생략 가능하다.
    ```

- 계산된 프로퍼티 이름

  - 문자열 또는 문자열로 타입변환 되는 값으로 평가되는 표현식을 사용해 프로퍼티를 동적으로 생성가능하다.
  - 단 대괄호([])로 묶어야한다. 이를 계산된 프로퍼티 이름(computed property name)이라 한다.

    ```javascript
    // ES5에서는 객체 리터럴 외부에서 선언해야함
    var prefix = "prop";
    var i = 0;

    var obj = {};

    obj[prefix + "-" + ++i] = i;
    obj[prefix + "-" + ++i] = i;
    obj[prefix + "-" + ++i] = i;

    console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}

    // ES6에서는 객체 리터럴 내부에서도 선언 가능
    const obj = {
      [`${prefix}-${++i}`]: i,
      [`${prefix}-${++i}`]: i,
      [`${prefix}-${++i}`]: i,
    };

    console.log(obj); // {prop-4: 4, prop-5: 5, prop-6: 6}
    ```

- 메서드 축약 표현
  - ES6에서는 function를 키워드 생략해 메서드를 정의 가능하다.
  ```javascript
  const obj = {
    name: "Lee",
    sayHi() {
      console.log("Hi!" + this.name);
    },
  };
  obj.sayHi(); // Hi Lee
  ```

# 11장 원시 값과 객체의 비교

- 원시 타입의 값은 변경 불가능한 값(immutable value), 객체 타입의 값은 변경 가능한 값(mutable value)이다.
- 원시 값을 변수에 할당하면 변수에는 실제 값이 저장되고 객체를 변수에 할당하면 참조 값이 저장된다.
- 원시 값을 가진 변수를 다른 변수에 할당하면 원시 값이 복사되어 전달 된다. 이를 값에 의한 전달이라 한다.
- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라고 한다.

## 원시 값

- 변경 불가능한 값
  - 원시 값은 읽기 전용으로 변경 불가능 한 것은 변수가 아니라 값에 대한 말이다.
  - 따라서 원시 값은 데이터의 신뢰성을 보장한다.
    ![test](https://i.ibb.co/ySxYjCf/image.png)
    - 변수가 참조하는 메모리 주소가 변하는 이유는 원시 값이 변경 불가능한 값이기 때문이다.
    - 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에는 변수 값을 변경할 방법이 없다.
- 문자열과 불변성
  - 변수에 원시 값을 갖는 변수를 할당하면 할당 받는 변수에는 할당 되는 변수의 원시 값이 복사되어 전달 된다. (값에 의한 전달)
  - 하지만 두 개의 변수에 할당된 값은 다른 메모리 공간에 저장된 별개의 값이다.
  - 따라서 "값에 의한 전달"도 사실은 값을 전달하는 것이 아닌 메모리 주소를 전달 하는 것이다.
  - 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.
  - 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.
    ![test2](https://i.ibb.co/5LNvSn6/image.png)

## 객체

- 변경 가능한 값

  - 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다.
    ![test3](https://i.ibb.co/CzyxdjH/image.png)
  - 원시 값은 재할당 밖에는 변수 값을 변경할 수 없지만 객체는 재할당 없이 객체를 변경 가능하다.
  - 재할당 없이 프로퍼티를 동적으로 추가할 수 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.

    ![test4](https://i.ibb.co/CzyxdjH/image.png)

- 객체는 크기가 매우 클 수도, 일정하지도 않으며 값이 객체일 수도 있어 복사해서 생성하면 비용이 많이 들기 때문에 객체는 변경 가능한 값으로 설계되어있다.
  - 이러한 구조로 여러 개의 식별자가 하나의 객체를 공유할 수 있다.
    - 얕은 복사는 객체에 중첩되있는 경우 참조 값을 복사
    - 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사
    - 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사
    - 객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사
- 참조에 의한 전달
  - 참조 값이 복사되어 전달 되는 것
  - 두 개의 식별자가 하나의 객체를 공유한다는 것을 의미한다.
    ![test5](https://i.ibb.co/Btq2NF1/image.png)
- "값에 의한 전달"과 "참조에 의한 전달"은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하기 때문에 "공유에 의한 전달" 이라고 표현하는 경우도 있다.

# 12장 함수

## 함수란?

- 함수는 일련의 과정을 문(statement)로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
- 매개변수 : 함수 내부로 입력을 전달 받는 변수
- 인수 : 입력
- 반환 값 : 출력
- 함수 정의 : 함수를 생성하는 것
- 함수 호출 : 인수를 매개변수를 통해 함수에 전달해 반환값을 반환하는 것

```javascript
function add(x, y) {
  return x + y;
}

var result = add(2, 5);
console.log(result);
```

## 함수를 사용하는 이유

- 함수를 필요할 때 여러번 호출하는 코드의 재사용
- 코드의 중복을 억제하고 재사용성을 높이는 함수는 유지보수의 편의성을 높임
- 실수를 줄여 코드의 신뢰성을 높임
- 적절한 함수 이름으로 코드의 가독성을 높임

## 함수 리터럴

- 함수 또한 함수 리터럴로 생성 가능하다.
  - 변수에 함수 리터럴 할당 가능
- 함수 이름
  - 함수 이름은 식별자로 네이밍 규칙을 준수해야 한다.
  - 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.
  - 함수 이름은 생략 가능하며 이름이 있는 함수를 기명 함수(named function)
  - 이름이 없는 함수를 무명/익명 함수(anonymous function)
- 매개변수 목록
  - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구별
  - 각 매개변수는 함수를 호출할 때 지정한 인수가 순서대로 할당된다.
  - 매개변수는 함수 몸체 내에서 변수와 동일하게 취급하며 매겨변수도 변수와 마찬가지로 네이밍 규칙을 준수해야한다.
- 함수 몸체
  - 함수가 호출되었을 때 일괄적으로 실행될 문을 하나의 실행 단위로 정의한 코드 블록
  - 함수 호출에 의해 실행
- 함수는 객체이다.
- 일반 객체는 호출할 수 없지만 함수는 호출 가능하다.

## 함수 정의

- 함수를 호출 하기 이전, 인수르 ㄹ전달받을 매개변수와 실행할 문 그리고 반환 값을 지정하는 것
- 함수의 정의 방식

  - 함수 선언문
    - 함수 이름 생략 X
    - 함수 이름을 생략할 수 없다.
    - 표현식이 아닌 문이다.
    - 선언문이 코드 위로 올려진 것처럼 동작하는 함수 호이스팅이 있다.

  ```javascript
  function add(x, y) {
    return x + y;
  }
  ```

  - 함수 표현식
    - 함수는 일급 객체다.
    - 함수 선언문으로 정의한 함수와 생성 시점이 다르다.
    - 함수 호이스팅이 아닌 변수 호이스팅이 발생한다.

  ```javascript
  var add = fuction(x, y) {
   return x + y
  };
  ```

  - Function 생성자 함수

  ```javascript
  var add = new Function("x", "y", "return x + y");
  ```

  - 화살표 함수(ES6)

  ```javascript
  var add = (x, y) => x + y;
  ```

- 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.
- ECMAScript에서는 변수에는 선언, 함수는 정의라고 표현한다.
  - 자바스크릡트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수를 할당한다.

## 함수 호출

- 매개 변수와 인수
  - 매개 변수가 많아지면 인수의 순서를 고려해야하며 순서가 변경되면 코드 전체가 영향을 받아 유지보수성이 나빠진다.
  - 매개 변수 개수는 적을수록 좋으며 이상적인 함수는 한가지 일만 해야하며 가급적 작게 만들어야한다.
    - 매개 변수는 3개 이상 넘지 않는 것을 권장
- 반환문
  - return 키워드와 표현식(반환 값)으로 이루어진 반환문으로 실행결과를 return한다.
    - 함수 호출은 표현식이다.
  - 함수의 실행을 중단하고 함수 몸체를 빠져나간다.
  - return 뒤에 오는 표현식을 평가해 반환한다.
  - 반환문은 생략 가능하다.
  - return키워드와 표현식 사이에 줄바꿈이 있으면 반환문에 세미콜론이 삽입되어 유의해야한다.
  - 함수 몸체 내부에서만 사용가능하다.
    - Node.js는 에러는 나지 않음

## 참조에 의한 전달과 외부 상태의 변경

- 자바스크립트에서 원시값은 값에 의한 전달, 객체는 참조에 의한 전달 방식으로 동작한다.
- 매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 또한 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따른다.
- 함수 외부에서 함수 몸체 내부로 전달한 원시 값의 원본을 변경하는 어떠한 부수효과도 발생하지 않는다.
- 함수 외부에서 하수 몸체 내부로 전달한 참조 값에 의해 원본 객체가 변경되는 부수 효과가 발생한다.
- 객체를 불변 객체(=immutable object)로 만들어 사용하면 해결된다.

## 다양한 함수의 형태

- 즉시 실행 함수
  - 함수정의와 함께 즉시 호출되는 함수
  - 즉시 실행 함수는 그룸 연산자(...)로 감싸야한다.
  - 코드를 모아두면 있을 수 있는 변수나 함수 이름의 충돌을 방지한다.
- 재귀 함수
  - 자기 자신을 호출하는 함수
  - 반복을 위해 처리한다.
  - 탈출 조건을 반드시 만들어야한다.
  - 무한반복에 빠칠위험과 스택오버플로 에러를 발생시켜 주의해야한다.
- 중첩 함수
  - 함수 내부에 정의된 함수
    - 충접 함수를 포함하는 함수는 외부 함수
  - 외부함수의 기능을 돕는 헬퍼함수
  - ES6부터는 문이 위치할수 있는 어디든 함수선언이 가능하나 if나 for문에서는 함수선언문을 통해 선언하면 호이스팅으로 인해 혼란을 부르므로 자제하는 것이 좋다.
- 콜백 함수
  - 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
    - 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달 받은 함수는 고차 함수라고 한다.
  - 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.
  - 콜백함수는 고차 함수에 의해 호출되며 고차함수는 필요에 따라 콜백함수에 인수를 전달한다.
- 순수 함수와 비순수 함수
  - 순수 함수
    - 부수 효과가 없다.
    - 언제나 동일한 값을 반환한다.
    - 최소 하나이상의 인수를 받는다.
  - 비순수 함수
    - 부수 효과가 있다.
    - 외부 상태에 따라 반환 값이 다르다.
