# 13장 스코프

## 13.1 스코프란?

스코프란?

- 식별자의 유효한 범위
- 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)은 자신이 선언한 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.
- 스코프의 후보는 변수 선언 가능 지역(코드의 가장 바깥영역/ 코드 블록/ 함수 몸체)
    - 이 중 코드 블록이나 함수는 중첩될 수 있다

스코프의 역할

- 스코프(유효범위)를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있게 한다.
- 스코프 내에서는 식별자는 유일해야 하지만, 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다

식별자 결정시의 규칙이기도 한 스코프

- 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야할 지 결정
- 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용되는 규칙이라고도 함

```jsx
var x = 'global';

function foo(){
  var x = 'local';
  console.log(x); // local
}

foo();

console.log(x); // global
```

중복 선언이 가능한 `var 키워드`

- 같은 스코프 내에서 중복 선언이 허용된다
- 의도치 않게 변수값이 재할당되어 변경되는 부작용이 발생
    
    ```jsx
    function foo() {
    	var x = 1;
    	var x = 2;  // 재할당된다
    	console.log(x);
    }
    ```
    

중복 선언이 불가능한 `const, let 키워드`

- 같은 스코프 내에서 중복 선언이 불가능
    
    ```c
    function bar() {
    	let x = 1;
    	let x = 2;  // SyntaxError: Identifier 'x' has already been declared
    }
    bar();
    ```
    

## 13.2 스코프의 종류

### 13.2.1 전역과 전역 스코프

전역이란? 

- 코드 가장 바깥쪽 영역 = 전역 스코프는 전역
- 전역 변수는 어디서든지 참조할 수 있다

### 13.2.2 지역과 지역 스코프

지역이란?

- 함수 몸체 내부를 의미
- 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효
- 같은 변수이름인 x가 존재하는 경우
    - 전역 변수 x  + 지역 변수 x (inner 함수)
        - 함수 내부에서는 지역 변수를 참조
        - 함수 외부에서는 전역 변수를 참조
- 이는 자바스크립트 엔진이 스코프 체인을 통해 참조할 변수를 검색했기 때문이다

## 13.3 스코프 체인

함수의 중첩이란?

함수 몸체 내부에서 정의한 함수를 말함

외부함수란?

중첩 함수를 포함하는 외부함수를 말함

함수가 중첩될 수 있다 = 함수의 지역 스코프가 중첩될 수 있다 = 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다 = 상위, 하위 스코프를 가짐

모든 지역 스코프의 최상위 스코프는 전역 스코프

스코프 체인이란?

- 스코프가 계층적으로 연결되어 있는 것

변수 검색이란?

- 변수 참조시 수행되는 로직을 말함
- 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색함
- 이를 통해 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조 가능

스코프 체인의 물리적인 실체

- 스코프 체인은 렉시컬 환경(물리적인 실체)로 존재함
    
    단계)
    
    - 자바스크립트 엔진은 코드(전역 코드와 함수 코드)를 실행하기 앞서 자료구조인 렉시컬 환경(Lexical Environment)을 실제로 생성함
    - 변수 선언이 실행되면 변수 식별자가 이 자료구조에 `키`(key)로 등록된다
    - 변수 할당이 일어나면 이 자료구조의 변수 식별자에 해당하는 `값`을 변경
    - 변수 검색도 이 자료구조 상에서 이루어진다

### 13.3.1 스코프 체인에 의한 변수 검색

방법

- 자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다

특징

- 하위로는 안내려감
    - 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조 가능O
    - 하위 스코프에서 유효한 변수를 상위 스코프에서 참조 불가능X

### 13.3.2 스코프 체인에 의한 함수 검색

<img width="426" alt="Untitled" src="https://github.com/morden-javascript-deep-dive/learning-summary/assets/117020232/1597a4d5-4399-46cc-86ca-5dca21120055">

- 모든 함수는 함수 이름과 동일한 이름의 식별자에 해당
- 함수 검색 = 식별자 검색
- 스코프는 “변수를 할당하기 위해 사용하는 규칙”이라고 표현하기 보다는 “식별자를 검색하는 규칙”

## 13.4 함수 레벨 스코프

- `코드 블록`이 아닌 `함수`에 의해서만 지역 스코프가 생성
- C나 자바 등을 비롯한 대부분 = 블록 레벨 스코프
    - 함수뿐만 아니라
    - 모든 코드 블록이 지역 스코프를 만듦 ex) if, for, while, try/catch 등
- var 키워드의 자바스크립트의 경우에는 = 함수 레벨 스코프
    - var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정

```jsx
var x = 1;

if (true) {
	var x = 10;  // 함수 레벨이 아닌 코드 블록이기에 전역변수 취급
}

console.log(x);  // 10
```

## 13.5 렉시컬 스코프

```c
var x = 1;
// bar 함수는 호출되는 곳에 상관없이 전역 스코프만이 상위 스코프로 갖는다.
function foo() {
	var x = 10;
	bar();
}

function bar() {
	console.log(x);
}

foo();  // 1
bar();  // 1
```

- bar 함수의 상위 스코프 결정하는 법
    
    1) 동적 스코프: 
    
    함수를 어디서 호출했는지에 따라 
    
    → bar 함수의 상위 스코프 = foo 함수의 지역 스코프 + 전역 스코프
    
    2) 렉시컬 스코프 or 정적 스코프: 
    
    함수를 어디서 정의했는지에 따라 
    
    → bar 함수의 상위 스코프는 전역 스코프 
    
    → 자바스크립트 등 대부분의 프로그래밍 언어는 렉시컬 스코프를 따름
---
# 14장. 전역 변수의 문제점

## 14.1 변수의 생명주기

### 14.1.1 지역 변수의 생명 주기

변수의 생명주기란?

- 변수는 선언에 의해 생성, 할당을 통해 값을 갖음. 그리고 언젠간 소멸
- 전역 변수의 생명주기 = 애플리케이션의 생명주기

전역변수로 선언된 함수

- 변수 선언은 런타임(코드 한줄씩 순차적으로 실행) 이전에 자바스크립트엔진에 의해 실행됨

함수 내부에 선언된 함수

- 함수 호출 직후에 함수 몸체의 코드가 한 줄씩 순차적으로 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행됨
- 지역변수의 생명 주기는 함수의 생명 주기와 일치함
    
    ```c
    function foo() {
    	// 1) 선언된 변수 x의 생성
    	// 2) 변수 x에 값을 할당
    	var x = 'local';
    	console.log(x);
    	return x;
    	// 3) 변수 x의 소멸
    }
    // 0) foo 함수의 호출
    foo();
    console.log(x);
    ```
    
- 함수 몸체 내부에서 선언된 지역 변수의 생명 주기는 함수의 생명 주기와 대부분 일치하지만
- 예외) 클로저(Closure):
    - 함수의 생명주기는 메모리 공간 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지
    - 즉, 누군가 메모리 공간을 참조하고 있으면 해제되지 않고 확보된 상태로 남아있게 됨.
    - 스코프 또한 메모리 공간과 마찬가지로 소멸되지 않고 생존하게 됨
- 함수 내에서의 호이스팅? = 호이스팅은 스코프 단위로 동작함
    - 호이스팅은 변수 선언이 스코프의 선두로 끌어올려진 것처럼 동작함
    
    ```c
    var x = 'global';
    
    function foo() {
    	// 함수 내에서 var x 선언이 함수(스코프) 내 제일 상단에 위치
    	console.log(x);   // undefined
    	var x = 'local';
    }
    
    foo();
    console.log(x);  // global
    ```
    

### 14.1.2 전역 변수의 생명주기

- 전역변수
    - 실행시점: 명시적 호출없이 실행 = 특별한 진입점 없고 코드가 로드되자마자 곧바로 해석되고 실행됨
    - 종료시점: 함수 몸체의 마지막 문 or 반환문 실행시 종료
- 함수
    - 실행시점: 함수 호출시
    - 종료시점: 마지막 문이 실행되어 더 이상 실행할 문이 없을때 종료

<img width="791" alt="스크린샷 2024-05-04 오전 9 48 00" src="https://github.com/morden-javascript-deep-dive/learning-summary/assets/117020232/04f6c39d-0b69-4c97-b9f6-6efb1b4bc9dd">

전역객체란?

- 코드 실행 이전 단계에서 먼저 생성되는 특수 객체
- 클라이언트 사이드 환경(브라우저)에서는 window
- 서버 사이드 환경(Node.js)에서는 global 객체를 의미
- ES11에서는 globalThis로 통합
- 전역 객체(`window`, `global`, `globalThis` 등)가 프로퍼티로 갖는 객체
    - 표준 빌트인 객체(Object, String, Number, Function, Array, …)
    - 환경에 따른 호스트 객체(클라이언트 web API, Node.js의 web API)
        
        <aside>
        💡 호스트 객체란?
        배경지식) 
        전역 객체는 실행 환경에 따라 다양한 호스트 객체(= 다양한 종류의 전역 객체)를 포함함
        정의) 
        - JS 실행 환경에서 제공하는 환경별 API를 의미
        - 호스트 객체는 실행 환경마다 다르며, 해당 환경에서 제공하는 기능과 속성을 사용할 수 있음
        예시) 
        - 브라우저 환경에서는 `window` 객체가 전역 객체 역할을 함.  `document`, `console`, `XMLHttpRequest` 등 브라우저에서 제공하는 API는 호스트 객체의 일부로 전역 객체의 프로퍼티로 제공됨
        - Node.js에서는 `global` 객체가 전역 객체 역할을 함. Node.js 환경에서는 `process`, `require`, `console` 등 Node.js의 내장 API들이 호스트 객체의 일부로 전역 객체의 프로퍼티로 제공됨.
        
        </aside>
        
    - var 키워드로 선언한 전역 변수와 전역 함수
        - 브라우저 환경에서 var 키워드로 선언한 전역 변수는 전역 객체는 window의 프로퍼티이다. 즉, var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치함.

## 14.2 전역 변수의 문제점

- 암묵적 결합
    - 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합의 허용
    - 변수의 유효범위가 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있음
- 긴 생명 주기
    - 메모리 리소스를 오랜 기간 소비
    - var 키워드는 중복 선언 허용하므로 의도치 않은 재할당 일어날 수도
- 스코프 체인 상에서 종점에 존재
    - 전역 변수의 검색 속도가 가장 느리다
    - 변수를 검색시 전역 변수가 가장 마지막에 검색된다
    - 하위 스코프에서 상위 스코프로 타고 올라가니깐
- 네임스페이스 오염
    - 파일이 분리되어 있어도 하나의 전역 스코프를 공유함 → 예상치 못한 결과를 가져올 수 있음

## 14.3 전역 변수의 사용을 억제하는 법

- 해결법)
    - 전역 변수보다는 지역 변수의 사용을 늘려야 함

### 14.3.1 즉시 실행 함수

- 정의) 함수 정의와 동시에 호출되는 함수
- 즉시 실행 함수의 변수로 만들어 전역 변수의 사용을 제한하자

### 14.3.2 네임스페이스 객체

- 장점) 네임스페이스를 분리해서 식별자 충돌을 방지할 수 있음
- 여전히) 네임스페이스 객체가 전역 변수
    
    ```jsx
    var MY = {};  // 전역 네임스페이스 객체
    
    MY.name = 'Hong';  // 전역 변수처럼 사용하고 싶은 객체 프로퍼티로 추가
    
    console.log(MY.name);  // Hong
    ```
    

### 14.3.3 모듈 패턴

- 정의) 클래스를 모방해 관련있는 변수와 함수를 모아 즉시 실행함수로 감싸 하나의 모듈을 만듦
- 특징)
    
    1) JS의 강력한 기능인 클로저를 기반으로 동작함
    
    2) 전역 변수의 억제 + 캡슐화 = 동시에 구현 가능
    
- 캡슐화란?
    - 객체의 상태를 나타내는 프로퍼티 + 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드 를 하나로 묶는
    - 정보 은닉의 목적으로 사용하기도 → 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 함
- 외부 노출 의도에 따라
    - 외부에 노출하고 싶은 변수나 함수를 반환 = 퍼블릭 멤버(public member)
    - 외부에 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않으면 외부에서 접근할 수 없는 프라이빗 멤버(private member)가 됨.

```jsx
var Counter = (function () {
	// private 변수
	var num = 0;
	
	// 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
	return {
		increase() {
			return ++num;
		},
		decrease() {
			return --num;
		}
	};
}());

//private 변수는 외부로 노출되지 않는다
console.log(Counter.num);  // undefined
console.log(Counter.increase);  // 1
console.log(Counter.increase);  // 2
console.log(Counter.decrease);  // 1
console.log(Counter.decrease);  // 0
```

### 14.3.4 ES6 모듈

- ES6 사용시 전역 변수 사용 못함 → ES6 모듈 내에서 선언한 var 키워드 변수는 더는 전역 변수가 아니며, window 객체의 프로퍼티도 아니다
- ES6 모듈은 파일 자체에 독자적인 모듈 스코프를 제공
- 사용법) script 태그에 type=”module” 속성을 추가하면 로드된 자바스크립트 파일은 모듈로서 동작함
- 모듈 파일의 파일 확장가는 mjs를 권장
    - 참고) `.js` 확장자와 `.mjs` 확장자의 주요 차이점
        1. **모듈 유형**:
            - **.js 확장자**: 기존의 JavaScript 파일은 CommonJS나 AMD와 같은 비 표준 모듈 시스템을 따르는 파일에 사용됩니다. 브라우저 환경이나 Node.js에서는 `require()` 함수와 `module.exports` 또는 `exports` 객체를 사용하여 모듈을 정의하고 로드합니다.
            - **.mjs 확장자**: ECMAScript 모듈(ESM)을 사용하는 파일에 해당합니다. `.mjs` 파일은 `import`와 `export` 키워드를 사용하여 표준화된 모듈 시스템을 따르는 파일을 나타냅니다.
        2. **파일 처리 방식**:
            - **.js 확장자**: 기존의 JavaScript 파일인 `.js`는 기본적으로 CommonJS나 AMD와 같은 비 표준 모듈 시스템을 사용하기 때문에, 브라우저나 Node.js는 이러한 파일을 일반적인 스크립트 파일로 처리합니다.
            - **.mjs 확장자**: ECMAScript 모듈인 `.mjs` 파일은 `type="module"` 어트리뷰트를 사용하여 모듈로써 명시적으로 로드되어야 합니다. 브라우저에서는 `<script type="module" src="module.mjs"></script>`와 같이 사용하며, Node.js에서는 `import` 문을 사용하여 모듈을 로드합니다.
        3. **환경 호환성**:
            - **.js 확장자**: `.js` 파일은 대부분의 브라우저와 Node.js에서 널리 지원되는 파일 형식입니다. 이는 CommonJS나 AMD 모듈 시스템을 사용하기 위한 파일로 활용됩니다.
            - **.mjs 확장자**: `.mjs` 파일은 ECMAScript 모듈 시스템을 지원하는 환경에서 사용됩니다. 브라우저의 최신 버전과 Node.js의 최신 버전에서 지원됩니다.
        4. **표준화와 미래 지향성**:
            - **.js 확장자**: 기존의 JavaScript 파일 형식인 `.js`는 CommonJS나 AMD와 같은 비 표준 모듈 시스템을 따르므로 표준화된 모듈 시스템의 규약과는 다소 차이가 있습니다.
            - **.mjs 확장자**: `.mjs` 파일은 ECMAScript 모듈 시스템을 표준으로 사용하므로 미래의 JavaScript 표준을 준수하고, 브라우저와 Node.js에서 모듈화를 명확하게 구현할 수 있습니다.
        
        따라서 `.mjs` 확장자는 ECMAScript 모듈 시스템을 사용하기 위한 파일 형식으로, `.js` 확장자는 기존의 CommonJS나 AMD 모듈 시스템을 따르는 파일 형식으로 구분됩니다. 선택할 환경과 사용하려는 모듈 시스템에 따라 적절한 확장자를 선택하여 파일을 작성하는 것이 중요합니다.
        

```jsx
<script type="module" src="app.mjs"></script>
```

- ES6 모듈은 IE 포함한 구형 브라우저에서는 동작하지 않음 → 아직까지는 Webpack 등이 모듈 번들러를 사용하는 것이 일반적 → 49장에서 Babel 과 webpack을 이용한 ES6+/ES.NEXT 개발환경구축에서 자세히

---
# 15장. let, cosnt 키워드와 블록 레벨 스코프

## 15.1 var 키워드를 선언한 변수의 문제점

ES5까지 변수를 사용할 수 있는 유일한 방법은 var 키워드였음

### 15.1.1 변수 중복 선언 허용

- var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용함
    - 초기화문이 있는 변수 선언문
        - 자바스크립트 자바스크립트 엔진에 의해 var 키워드가 없슨 것처럼 동작함
    - 초기화문이 없는 변수 선언문
        - 무시됨

```jsx
var x = 1;
var y = 1;

var x = 100;  // 100으로 x를 중복선언함 -> 위의 var 키워드 없는 것처럼 동작
var y;  // 초기화문이 없어 무시됨 -> 에러 발생 X

console.log(x);  // 100 
console.log(y);  // 1
```

### 15.1.2 함수 레벨 스코프

- var 키워드로 선언된 변수는 오직 `함수의 코드 블록`만을 지역 스코프로 인정

```jsx
var i = 10;

for (var i = 0; i < 5; i++) {
	console.log(i);  // 0 1 2 3 4 
}

// 의도치 않게 i 변수의 값이 변경되었다.
console.log(i);  // 5
```

### 15.1.3 변수 호이스팅

- var 키워드로 변수 선언하면, 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어올려짐.
- 즉, 변수 선언문 이전에 참조할 수 있다.
- 단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환함.

```jsx
// 1) 선언 단계: 변수 호이스팅에 의해, 선언문 이전에 이미 foo 변수가 선언됨
// 2) 초기화 단계: 변수 foo는 undefined로 초기화된다
console.log(foo);  // undefined
foo = 123;  // 변수에 값을 할당
console.log(foo);  // 123
var foo;
```

## 15.2 let 키워드

- var 키워드의 단점을 보완하기 위해 ES6에서 새로운 변수 선언 키워드인 let과 const가 등장함

### 15.2.1 변수 중복 선언 금지

- let 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러(SyntaxError)가 발생
    
    ```jsx
    var foo = 123;
    var foo = 456;
    
    let bar = 123;
    let bar = 456;  // SyntaxError: Identifier 'bar' has already been declared
    ```
    

### 15.2.2 블록 레벨 스코프

- let 키워드는 모든 `코드 블록`을 지역 스코프로 인정 = 블록 레벨 스코프
    - 모든 코드 블록(함수, if문, for문, while문, try/catch문 등…)

### 15.2.3 변수 호이스팅

- var 키워드는 런타임 이전에 자바스크팁트 엔진에 의해 암묵적으로 “선언 단계”와 “초기화 단계”를 거친다
- let 키워드로 선언한 변수는 `선언 단계`와 `초기화 단계`가 분리되어 진행됨
    - 선언단계) 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언단계가 실행
    - 초기화단계) 변수 선언문에 도달했을 때 실행
    - 즉, 선언단계와 초기화단계 사이에 접근하게 되면 참조에러(ReferenceError)가 발생
    - 이 구간을 일시적 사각지대(TDZ)라 함
    
    <img width="799" alt="스크린샷 2024-05-04 오후 12 11 40" src="https://github.com/morden-javascript-deep-dive/learning-summary/assets/117020232/f1d595ef-3698-4e42-96e1-6a2ca6daa2a7">

    ```jsx
    // 1) 런타임 이전에 선언 단계 실행
    console.log(foo)  // undefined
    let foo;  // 2) 선언문에서 초기화 단계 실행
    console.log(foo)  // undefined
    foo = 1  // 3) 할당문에서 할당 단계가 실행
    console.log(foo)  // 1
    ```
    
- `let`, `const`, `class`를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다 = 호이스팅이 발생하지만 TDZ의 영향을 받아 초기화 이전에 접근할 수 없다. = TDZ 구간에선 ReferenceError가 뜬다
    
    ```jsx
    let foo = 1;  // 전역 변수
    
    {
    	console.log(foo);  // ReferenceError: Cannot access 'foo' before initialization
    	// 지역 변수 foo의 호이스팅이 발생하지 않았다면, 전역 변수 foo인 1의 값이 나왔어야 함. 
    	let foo = 2;  // 지역 변수
    }
    ```
    

### 15.2.4 전역 객체와 let

- let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉, window.x로 접근 불가
- let 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드… 23장에서)내에 존재하게 된다

```jsx
let x = 1;
console.log(window.x);  // undefined
console.log(x);  // 1
```

## 15.3 const 키워드

- const 키워드는 상수를 선언하기 위해 사용
- 반드시 상수만을 위해 사용하지는 않음… 아래에 프로퍼티 값만 변경할 경우 사용

### 15.3.1 선언과 초기화

- const 키워드 선언한 변수 = 선언과 동시에 초기화해야함. → 그러지 않으면 문법에러 발생
    
    ```jsx
    const foo = 1;
    const bar;  // SyntaxError:Missing initializer in const declaration
    ```
    
- const 키워드로 선언한 변수는 블록 레벨 스코프를 가짐 = 호이스팅이 발생하지 않는 것처럼 동작함. 즉, TDZ 존에서는 SyntaxError가 뜸.

### 15.3.2 재할당 금지

- const 키워드로 선언한 변수는 재할당이 금지됨

### 15.3.3 상수

- 상수는 재할당이 금지된 변수(변수라고 한 이유는, 상수 또한 값을 저장하기 위한 메모리 공간이 필요함으로)
- 그냥 `0.1` 보다는 `TAX_RATE` 라는 이름의 상수를 선언해 0.1 대신 사용함으로서 가독성을 높일 수 있음
- 표현방법) 상수의 이름은 대문자로 선언해 상수임을 명확히 나타냄 + 언더바(_)사용함

### 15.3.4 const 키워드와 객체

- const 키워드로 선언된 변수에 `원시값`할당한 경우 → 값 변경 불가
- const 키워드로 선언된 변수에 `객체`를 할당한 경우 → 변경 가능
    
    ```jsx
    const person = {
    	name: 'Lee'
    };
    
    person.name = 'Hong';
    
    console.log(person);  // {name: "Hong"}
    ```
    
    - 즉, const 키워드는 재할당을 금지할 뿐, 프로퍼티의 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경하는 것은 가능함.

## 15.4 `var` vs `let` vs `const`

<aside>
💡 변수 선언시,  키워드 활용 권장
재할당 불필요시엔 → const
재할당 필요시엔 → let (단, 범위를 좁게 만들자)

* ES6를 사용한다면 var 키워드는 사용하지 않는다

</aside>
