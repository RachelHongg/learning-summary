# 13장 스코프

## 스코프란?

- 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위
- 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야할 지 결정하는 식별자 결정(identifier resolution)을 한다.
- 스코프는 식별자를 검색할 때 사용하는 규칙이다.
- 전역 변수와 함수 내에서 선언된 변수는 이름이 동일해도 스코프가 다른 별개의 변수다.
  - 만약 스코프가 없다면 프로그램 전체에서 변수는 하나의 이름만 가진다.
- 스코프는 네임스페이스이다.
  - 스코프를 통해 같은 이름의 변수를 사용할 수 있게 한다.

## 스코프의 종류

- 전역과 전역 스코프
  - 코드의 가장 바깥 영역, 전역에 변수를 선언하면 전역 스코프를 가지는 전역 변수가 된다.
  - 전역 변수는 어디든지 참조가 가능하다.
- 지역과 지역 스코프
  - 지역은 함수 몸체 내부, 지역은 지역 스코프를 만들며 지역에 변수 선언 시 지역 변수가 된다.
  - 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.

## 스코프 체인

- 스코프는 중첩 함수로 인해 계층적 구조를 가질 수 있다.
- 중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 계층적 구조를 가진다.
- 전역 스코프, 외부함수의 스코프, 중첩 함수의 스코프 순서대로 계층적으로 연결 된 것을 스코프 체인이라고 한다.
- 스코프 체인에 의한 변수 검색
  - 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작해 상위 스코프 방향으로 이동하며 변수를 검색한다.
  - 중첩 함수에서 먼저 변수 검색->외부 함수에서 변수가 존재하는지 검색->전역 변수에서 변수가 존재하는지 검색, 만약 변수가 존재한다면 검색 종료
  - but, 상위 스코프에서 유효한 변수는 하위 스코프에서 참조 가능하나 하위 스코프에서 유효한 변수를 상위 스코프에서 사용하진 못함
- 스코프 체인에 의한 함수 검색
  - 전역 함수에 썼던 함수명을 중첩함수에 쓴다면 각자 다른 스코프로 인해 별개의 함수가 된다.
  - 이를 통해 스코프는 변수를 검색할 때 사용하는 규칙이 아닌 식별자를 검색하는 규칙이라고 볼 수 있다.

## 함수 레벨 스코프

- 지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만들기 때문에 지역 스코프는 함수에 의해 만들어진다.
- C, 자바는 모든 코드 블록이 지역 스코프를 만드는 블록 레벨 스코프 특성이 있지만 자바스크립트는 var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하며 이런 특성을 함수 레벨 스코프라고 한다.
- but, let, const 키워드는 블록 레벨 스코프를 지원한다.

## 렉시컬 스코프

- 동적 스코프
  - 함수를 어디서 호출 했는지에 따라 함수의 상위 스코프를 결정한다.
- 렉시컬 스코프, 정적 스코프
  - 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.
- 자바스크립트는 렉시컬 스코프를 따르기 대문에 함수의 상위 스코프를 언제나 자신이 정의된 스코프다.
- 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정되며 결정된 상위 스코프를 기억해 함수가 호출 될때마다 함수의 상위 스코프를 참조한다.

# 14장 전역 변수의 문제점

## 변수의 생명 주기

- 변수의 생명 주기는 메모리 공간이 확보 된 시점부터 메모리 공간이 해체되어 가용 메모리 풀에 반환되는 시점까지 이다.
- 지역 변수의 생명 주기
  - 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다.
  - 변수 호이스팅은 전역 변수에 해당하며 지역 변수는 해당하지 않는다.
  - 지역 변수는 함수가 호출되면 함수의 다른 코드가 실행되기 이전에 지역 변수가 undefined로 선언된다.
  - 지역 변수의 생명주기는 함수의 생명주기와 일치하다.
  - 호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 특징이다.
- 전역 변수의 생명 주기
  - 전역 코드는 코드가 로드되자마자 곧바로 해석되고 실행되며 반환문을 사용할 수 없으므로 마지막 문을 실행하여 종료한다.
  - var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. 이는 전역 변수의 생명주기는 전역 객체와 일치하는 것을 뜻한다.

## 전역 변수의 문제점

- 암묵적 결합
  - 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합(implicit coupling)을 허용해 코드의 가독성이 나빠지고 의도치않게 상태가 변경된다.
- 긴 생명 주기
  - 전역 변수는 생명 주기가 길어 메모리 리소스도 오랜 기간 소비한다.
- 스코프 체인 상에서 종점에 존재
  - 가장 마지막에 검색되므로 전역 변수의 검색 속도가 가장 느리다.
- 네임스페이스 오염
  - 파일이 분리되어도 하나의 전역 스코프를 공유해 다른 파일 내의 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가지고 올 수 있다.

## 전역 변수의 사용을 억제하는 방법

- 전역 변수를 반드시 사용해야할 이유를 찾지 못하면 지역 변수를 사용해라 스코프는 좁을 수록 좋다.
- 즉시 실행 함수
  - 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.
  - 라이브러리 등에 자주 사용된다.
- 네임 스페이스 객체
  - 전역에 네임 스페이스를 담당할 객체를 생성해 전역 변수처럼 사용하고 싶은 변수를 프로퍼티에 추가하는 방식이다.
  - 식별자 충돌 방지는 가능하나 네임스페이스 자체가 전역에 할당되어 유용해 보이지 않는다.
- 모듈 패턴
  - 클래스를 모방해 관련있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다.
  - 전역 변수의 억제는 물론 캡슐화까지 구현 가능하다.
  - 전역 네임스페이스의 오염을 막고 한정적이지만 정보 은닉을 구현하기 위해 사용한다.
- ES6 모듈
  - 파일 자체의 독자적인 모듈 스코프를 제공한다.
  - 따라서 var키워드로 선언한 변수는 더는 전역 변수가 아니며 window객체의 프로퍼티도 아니다.
  - 트랜스파일링이나 번들링이 필요해 아직까지는 Webpack 등의 모듈 번들러를 사용한다.

# 15장 let, const 키워드와 블록 레벨 스코프

## var 키워드로 선언한 변수의 문제점

- 변수의 중복 선언 허용
  - 중복 선언이 가능해 의도치 않게 먼저 선언된 변수 값이 변경되는 부작용이 있다.
- 함수 레벨 스코프
  - 함수 외부에서 선언된 var키워드 변수는 코드 블록 내에 선언해도 모두 전역 변수가 된다. ex)if, for
- 변수 호이스팅
  - 호이스팅에 의해 변수 선언문 이전에 참조가 가능해 가독성을 떨어트리고 오류를 발생시키는 여지가 있다.

## let 키워드

- 변수 중복 선언 금지
  - let 키워드로 이름이 같은 변수를 중복 선언하면 문법에러(SyntacError)가 발생한다.
- 블록 레벨 스코프
  - 함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프와 달리 모든 코드 블록(if, for, while, try/catch)등을 지역 스코프로 인정하는 블록 레벨 스코프이다.
- 변수 호이스팅
  - let 키워드 변수를 변수 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생해 변수 호이스팅이 발생하지 않는 것처럼 동작한다.
  - let 키워드는 var과 달리 선언 단계와 초기화 단계가 분리되어 진행된다.
    - 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언이 되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다.
    - 초기화 단계가 실행되기 전, 변수를 참조했을 때 에러가 생겨 참조하지 못하는 것을 일시적 사각지대(Temporal Dead Zone: TDZ)라고 한다.
    - 호이스팅이 발생은 하지만 에러를 통해 발생하지 않는 것처럼 보이게 한다.
- 전역 객체와 let
  - let으로 선언된 전역 변수는 전역 객체의 프로퍼티가 아니라 window.foo 와 같이 접근이 불가능 하다.
  - let 전역 변수는 보이지 않는 개념적인 블록 내에 존재한다.

## const 키워드

- 상수를 선언하기 위해 사용하지만 상수만을 위해 사용하는 것은 아니다.
- 선언과 초기화
  - const로 선언한 변수는 반드시 선언과 동시에 초기화 해야한다.
    - 그렇지 않으면 문법 에러가 발생한다.
  - const 또한 변수 호이스팅이 일어나지 않는 것처럼 동작한다.
- 재할당 금지
  - var, let과 달리 재할당이 금지 된다.
- 상수
  - const는 상수로 재할당이 금지된 변수를 말한다.
  - 상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야한다.
  - 상수의 이름은 대문자로 선언하며 여러 단어라면 언더스코어(\_)로 구분한다.
- const 키워드와 객체
  - const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다.
  - const는 재할당을 금지할 뿐 "불변"을 의미하진 않는다.
    - 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체 값을 변경하는 것은 가능하다.

## var vs. let vs. const

- ES6를 사용하면 var 키워드는 사용하지 않는다.
- 재할당이 필요한 경우에 한정해 let을 사용하며 이때 변수의 스코프는 최대한 좁게 만든다.
- 변경이 발생하지 않고 읽기 전용으로 사용하는 원시 값과 객체에는 const를 사용한다. const는 재할당을 금지하므로 var, let보다 안전하다.
- 변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에만 한정적으로 사용하는 것이 좋다.
