✳️ **7장: 연산자**

피연산자 : 값 (명사)

연산자 : 피연산자를 연산하여 새로운 값을 만든다. (동사)

7.1 산술 연산자

- **이항 산술 연산자**

2개의 피연산자를 산술 연산하여 숫자 값을 만든다.

피연산자의 값이 바뀌는 경우는 없고 언제나 새로운 값을 만드므로 side effect 가 없다.

`+`, `-`, `*`, `/` , `%`

- **단항 산술 연산자**

1개의 피연산자를 산술 연산하여 숫자 값을 만든다.

증가/감소 연산자는 피연산자의 값을 변경하는 side effect 가 있다.

`++` , `--`, `+`, `-`

```jsx
var num = 1;
num++; // 2

var result;

// 위치에 의미가 있다.
result = ++num; // result : 3, num : 3
result = num++; // result : 3, num : 4
```

```jsx
// 피연산자를 숫자 타입으로 변환하여 반환한다.
+10;
+(-10);

// 부호를 반전한다고 하더라도 피연산자를 변경하는 것은 아니고
// 부호를 반전한 값을 생성해 반환하므로 부수 효과는 없다.
-10;
-(-10);
```

- 문자열 연결 연산자

`+`  연산자는 피 연산자 중 

하나 이상이 문자열인 경우 → 문자열 연결 연산자

그 외의 경우 → 산술 연산자로 동작한다.

```jsx
'1' + 2; // '12' (2가 '2'로 타입변환)
1 + null // 1 (null이 0으로 타입변환)
1 + undefined // NaN (undefined는 숫자로 타입 변환되지 않음)
```

- **암묵적 타입변환(= 타입 강제 변환)**

개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동변환되는 현상

7.2 할당 연산자

우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.

좌항의 변수 값이 변하므로 side effect가 있다.

`=`, `+=`, `-=`, `*=`, `/=`, `%=`

할당문 → 값으로 평가되는 **표현식**인 문으로서 할당된 값으로 평가

```jsx
var a,b,c;
a = b = c = 0;

var x = a = b = c = 0; // 변수에 할당해본다. (O)
```

7.3 비교 연산자

- 동등/일치 비교 연산자

`==`, `===`, `!=`, `!==`

| == : 동등 비교(느슨한 비교)  | 값이 같다. |
| --- | --- |
| === : 일치 비교(엄격한 비교)  | 값과 타입이 같다. |

동등 비교 연산 시, 암묵적 타입 변환을 통해 타입을 일치 시킨 후 같은 값인지 비교함(자바스크립트 엔진→결과 예측 어려움)

```jsx
var num1 = NaN;
var num2 = NaN;

num1 === num2 // false

Number.isNaN(num1) === Number.isNaN(num2); // true
Object.is(NaN) === Object.is(undefined + 1); // true
```

- 대소 관계 비교 연산자

`>`, `<`, `>=`, `<=`

7.4 삼항 조건 연산자

`조건식?true일때 반환값:false일때 반환값`

- 삼항 조건 연산자 표현식
    
    값처럼 사용( 다른 표현식의 일부가 될 수 있어서 유용함) 🌟
    
    - 조건에 따라 어떤 값을 결정해야 한다
- `if… else`문
    
    표현식이 아닌 문(값처럼 사용 X)
    
    - 조건에 따라 수행해야 할 문이 하나가 아니라 여러개다.

7.5 논리 연산자

`||`, `&&`, `!`

논리부정(`!`) → 언제나 boolean 값 반환

논리합, 논리곱(`||`, `&&`) → 2개의 피연사자 중 어느 한쪽으로 평가(boolean 값이 아닐 수 있음)

7.6 쉼표 연산자

차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

```jsx
var x, y, z;
x = 1, y = 2, z = 3; // 3
```

7.7 그룹 연산자

우선순위가 가장 높다.

7.8 typeof 연산자

typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환 한다.

7개 데이터 타입과 정확히 일치하지는 않는다.

`string`, `number`, `boolean`, `undefined`, `symbol`, `object`, `function`

`null` 을 반환하는 경우는 없다! → `object` 반환

7.9 지수 연산자

ES7 에서 도입된 지수 연산자 `**`

지수 연산자 도입되기 이전에는 `Math.pow(x, y)` 메서드를 사용했다.

```jsx
2 ** 3 // 8
Math.pow(2,3) // 8
```

이항 연산자 중에서 우선 순위가 가장 높다.

```jsx
2 * 5 ** 2 // 2 * 25 = 50
```

7.10 그 외의 연산자

`?.`, `??`, `delete`, `new`, `instanceof`, `in`

7.11 연산자의 부수 효과

부수효과 = side effect = 다른 코드에 영향을 준다.

할당 연산자(`=`), 증가/감소 연사자(`++`/`--`), `delete` 연산자

```jsx
var obj = { name: "obj"};
delete obj.name; // obj 객체의 프로퍼티 삭제
console.log(obj); // {}
```

7.12 연산자 우선순위

연산자의 우선순위가 존재하나, 기억하기 어려우며 실수하기 쉬우니 그룹 연산자`()`를 사용하여 우선순위 명시적으로 조절

7.13 연산자 결합 순서

연산자의 어느 쪽부터 수행할 것인지를 나타내는 순서

좌항→우항 or 우항→좌항


✳️ **8장: 제어문**

**제어문**

제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다.

제어문은 코드의 실행 흐름을 인위적으로 제어할 수 있다. 

→ 순자적으로 진행하는 직관적인 코드의 흐름을 혼란스럽게 만든다.

→  가독성을 해치는 단점이 있으며, 이는 오류를 발생시키는 원인이 될 수 있다.

8.1 블록문

0개 이상의 문을 중괄호로 묶은 것 = **코드 블록, 블록**

하나의 실행 단위로 취급

자체 종결성을 갖기 때문에 세미콜론을 붙이지 않음

8.2 조건문

주어진 조건식의 평가 결과에 따라 코드 블록의 실행을 결정한다.

`boolean` 값으로 평가될 수 있는 표현식

- if...else 문

```jsx
var num = 10;
if(num > 10) {
   num = 11;
}
else {
  num = 9;
}

// 삼항 조건 연산자로 변경
num = num>10 ? 11: 9;
```

- switch 문

```jsx
var month = 4;
var monthName;

switch(month) {
  case 1:
    monthName = 'January';
    break; // break 를 하지 않으면 다음 case 문으로 넘어감.
  //..
  default:
	  monthName = 'Invalid';
	  break;
}
```

8.3 반복문

- for 문

`for(var i = 1; i<10; i++) {…}`

`for(;;)` - 무한루프

- while 문

`while(true) {…}` - 무한루프

무한루프이므로 탈출 조건이 필요함(`break`)

- do...while 문

코드 블록을 먼저 실행하고 조건식을 평가한다. → 코드 블록이 무조건 한 번은 실행

8.4 break 문

레이블 문, 반복문, switch 문의 코드 블록을 탈출한다.

→ 이외에 사용 시, SyntaxError 발생

```jsx
var x = 0;
var z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops: " + x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops: " + z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

break문은 가장 가까운 반복문을 탈출하지만, 레이블 문을 사용하여 외부 반복문을 탈출할 수도 있다.
-> 하지만 레이블 문은 가독성이 나빠져 권장되지는 않는다.

8.5 continue 문

반복 문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.

```
i = 0;
n = 0;
while (i < 5) {
  i++;
  if (i == 3) {
    continue;
  }
  n += i; // i가 3일때 실행되지 않음
}
```

✳️ **9장: 타입 변환과 단축 평가**

9.1 타입 변환이란?

- 명시적 타입변환 or 타입 캐스팅

개발자가 의도적으로 값의 타입을 변환하는 것

```jsx
var x = 10;
var str = x.toString(); // typeof str === 'string'
```

- 암묵적 타입변환 or 타입 강제 변환

 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 변환되는 것

→ 코드 예측가능성이 떨어질 수 있음

```jsx
var x = 10;
var str = x + ''; // typeof str === 'string'
```

→ 기존 변수 값을 재할당하여 변경하는 것은 아니다.

→ 기존 값을 사용해 다른 타입의 값을 새로 생성 하는 것

9.2 암묵적 타입 변환

코드 문맥에 부합하지 않은 상황이 발생 시 에러를 발생시키기도 하지마, 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식 평가

- 문자열 타입으로 변환

```jsx
'1' + 2 // '12'
```

→ `'1'`은 문자열이다.
→ 피연산자 하나 이상이 문자열 이므로, `+`는 문자열 연결 연산자로 동작한다.
→ 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입변환한다.

- 숫자 타입으로 변환

```jsx
'1' - 1 // 0
'one' - 1 // NaN
```

→ `-`는 산술연산자이다.

→ 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입변환한다.

→ 숫자 타입으로 변환할 수 없는 경우는 산술 연산울 수행할 수 없으므로 평가 결과는 `NaN`이 된다.

- 불리언 타입으로 변환
    
    불리언 타입이 아닌 값을 Truthy 값 또는 Falsy 값으로 구분한다.
    
    불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 `true`, Falsy 값은 `false`로 암묵적 타입 변환 된다.
    
    - Falsy 값 : false, undefined, null, 0, NaN, ‘’(빈문자열)
    - Truthy 값 : Falsy 값이외의 모든 값

9.3 명시적 타입 변환

- 문자열 타입으로 변환
    - `String()` 생성자 함수
    - `Object.property.toString()` 함수 사용
    - 문자열 연결 연산자(`+`)를 이용하는 방법

- 숫자 타입으로 변환
    - `Number()` 생성자 함수
    - `parseInt()`, `parseFloat()` 함수 사용 (문자열 → 숫자)
    - `+` 단항 산술 연산자 이용
    - `-` 산술 연산자 이용

- 불리언 타입으로 변환
    - `Boolean()` 생성자 함수
    - ! 부정 논리 연산자를 두번 사용하는 방법

9.4 단축 평가

- 논리 연산자를 사용한 단축 평가

단축평가 : 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환

→ 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정 생략

```jsx
// 'CAT', 'DOG' 모두 Truthy 값이다.
'CAT' || 'DOG' // 'CAT' (Truthy || Truthy)
'CAT' && 'DOG' // 'DOG' (Truthy && Truthy)
```

- 옵셔널 체이닝 연산자
    
    `?.` 옵셔널 체이닝(optional chaining) 연산자
    
    - 좌항의 피연산자가 `null` 또는 `undefined` → `undefined` 반환
    - 그렇지 않은 경우 → 우항의 프로퍼티를 참조

- null 병합 연산자
    
    `??` 병합 연산자(nullish coalescing) 연산자
    
    - 좌항의 피연산자가 `null` 또는 `undefined` → 우항의 피연산자를 반환
    - 그렇지 않은 경우 → 좌항의 프로퍼티를 참조
