# 7장. 연산자
    
    - 연산자란?
        - 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행
    - 피연산자
        - 연산의 대상자 = 값으로 평가될 수 있는 표현식이어야
    
    ```jsx
    // 산술 연산자
    5 * 4
    // 문자열 연결 연산자
    'My name is" + "seonu"
    // 할당 연산자
    color = 'red'
    // 비교 연산자
    3 > 5
    // 논리 연산자
    true && false // -> false
    // 타입 연산자
    typeof 'Hi' // -> string
    ```
    
## 7.1 산술연산자
    
    - 피연산자로 새로운 숫자 값 만듦 / 불가능한 경우 NaN
    
### 7.1.1 이항 산술 연산자
    
    - 부수효과X: 피연산자를 바꾸지 못함
        
        / 나눗셈
        
        % 나머지
        
    
### 7.1.2 단항 산술 연산자
    
    - (++ / —) (증가 / 감소)
        - 전위 증가/감소 연산자: 먼저 피연산자의 값을 증가/감소한 후, 연산 수행
        - 후위 증가/감소 연산자: 연산 수행 후, 피연산자의 값을 증가/감소
    - + :  `숫자 타입이 아닌 → 숫자 타입으로 바꿈`
    - - : `숫자 타입이 아닌 → 숫자 타입으로 바꿈` + `피연산자의 부호 전환`
    
### 7.1.3 문자열 연결 연산자
    
    - + 는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작
    - 암묵적 타입 변환 또는 타입 강제 변환
        - 숫자 + 숫자 = 합 연산 수행
        - 숫자 + 문자열  = 문자열 수행 ( 숫자를 문자로 바꿔 연산 수행)
        - 문자열 + 문자열 = 문자열
        - 1 + true = 2 (true를 숫자 1로 바꾼 후 연산 수행)
    
 ## 7.2 할당 연산자
    
    ```jsx
    x += 5 // x = x + 5
    x *= 5 // x = x * 5 
    x /= 5 // x = x / 5
    x %= 5 // x = x % 5
    ```
    
    - 할당문은 표현식이다 (표현식은 값으로 평가될 수 있는 것 =  출력하면 출력되는)
    
## 7.3 비교 연산자
    
    좌항과 우항 비교후 불리언 값으로 반환
    
### 7.3.1 동등/일치 비교 연산자
    
    == (동등 비교) : 값이 같은지: 느슨한 비교
    
    ===(일치 비교): 값과 타입이 같은지
    
    ! = (부동등 비교): 값이 다름
    
    ! == (불일치 비교): 값과 타입이 다름
    
    ```jsx
    '0' == false // true
    '0' === 0 // false
    ```
    
    - 주의1)  NaN은 자신과 일치하지 않은 유일한 값
        
        ```jsx
        NaN === NaN // false
        ```
        
        NaN인지 알려면, 빌트인 함수인 `Number.isNaN` 을 사용하자.
        
        ```jsx
        Number.isNaN(NaN); // true
        Number.isNaN(10);  // false
        ```
        
    - 주의2) -0(음의 0)과 0(양의 0)은 동치
        
        자바스크립트에는 양의 0과 음의 0 동시에 존재함
        
        ```jsx
        0 == -0  // true
        0 === -0 // true
        ```
        
    - ES6에서 도입된 [Object.is](http://Object.is) 메서드를 이용하면 예측 가능한 가장 정확한 비교 결과를 반환
        
        ```jsx
        -0 === +0 ;          // true
        Object.is(-0, +0);   // false
        
        NaN === NaN;         // false
        Object.is(NaN, NaN); // true
        ```
        
    
### 7.3.2 대소 관계 비교 연산자
    
    피연산자 크기를 비교해서 불리언 값을 반환
    
    < = , > =, < , >
    
## 7.4 삼항 조건 연산자
    
    조건식의 평가 결과에 따라 반환할 값을 결정
    
    ```jsx
    조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값
    ```
    
    조건식은 불리언 타입으로 평가될 표현식
    
    만약, 조건식이 불리언 타입이 아니면 암묵적으로 타입이 변환된다
    
## 7.5 논리 연산자
    
    || : 논리합(OR)
    
    ```jsx
    true || true // true
    true || false // true
    false || false // false
    ```
    
    &&: 논리곱(AND)
    
    ```jsx
    true && true  // true
    true && false // false
    false && false // false
    ```
    
    - 논리합(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다.
    - 언제나 표현식 2개의 피연산자 중 한쪽으로 평가됨
    
    !: 부정(NOT)
    
    ```jsx
    !0 // true (0은 false이므로)
    !'Hello' // false
    ```
    
    - 논리 부정은 항상 불리언 값을 반환한다
    - 단, 피연산자가 반드시 불리언 값일 필요가 없다( 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환됨)
    
    팁
    
    - 드모르간의 법칙을 통해 가독성 좋은 표현식으로 변환 가능
        
        ```jsx
        !(X || y) === (!x && !y)
        !(x && y) === (!x || !y)
        ```
        
    
## 7.6 쉼표 연산자
    
    쉼표(,) 연산자는 왼쪽부터 피연산자를 평가하고 마지막 피연산자의 평가 끝나면 마지막 피연산자의 평가 결과를 반환
    
    ```jsx
    var x, y, z;
    x = 1, y = 2, z = 3; // 마지막 평과결과인 3을 반환
    ```
    
## 7.7 그룹 연산자
    
    소괄호() 로 묶인 피연산자 표현식이 가장 먼저 평가됨. 소괄호로 묶인 그룹 연산자는 연산자 우선순위가 가장 높다
    
## 7.8 typeof 연산자
    
    typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환함
    
    typeof 연산자는 7가지 문자열 중 하나를 반환함
    
    “string”, “boolean”, “undefined”, “symbol”, “object”, “function”
    
    - 주의1) 자바스크립트의 첫번째 버그인 null의 타입에 object를 반환
        
        null 타입인지 확인하기 위해서는 typeof 연산자보단 일치 연산자(===)를 사용하자
        
        ```jsx
        var foo = null;
        
        typeof foo; // object
        foo === null // true
        ```
        
    - 주의2) 선언하지 않은 식별자를 typeof로 연산하면 ReferrenceError가 아니라, undefined를 반환함
        
        ```jsx
        //undeclared 식별자를 선언하지 않음
        typeof undeclared; // undefined
        ```
        
    
## 7.9 지수 연산자
    
    - ES7에서 도입됨. 좌항을 피연산자 밑으로, 우항을 지수로 거듭 제곱함
    - 지수 연산자 도입전엔 Math.pow를 사용함. 지수연산자(**) 도입으로 가독성이 좋아짐
    - `**=` 처럼 할당연산자로도 사용가능
    - 이항 연산자 중에 우선순위가 가장 높다
        
        ```jsx
        2 * 5 ** 2 // 50 반환
        ```
        
    
## 7.10 그 외의 연산자
    
    `?.` 옵셔널 체이닝 연산자
    
    `??` null 병합 연산자
    
    `delete` 프로퍼티 삭제
    
    `new` 생성자 함수를 호풀시 사용하여 인스턴스 생성
    
    `instanceof` 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 확인
    
    `in` 프로퍼티 존재 확인
    
## 7.11 연산자의 부수 효과
    
    부수효과란?
    
    - 다른 코드에 영향을 주는
    
    ex) 할당 연산자(할당통해 변수 값 변함), 증가/감소 연산자(증감으로 변수가 값 변함), delete 연산자(객체의 프로퍼티를 삭제함)
    
    ## 7.12 연산자 우선순위
    
    1순위) ()
    
    2순위) new(매개변수 존재), [](프로퍼티 접근), ()(함수 호출), ?.(옵셔널 체이닝 연산자)
    
    3순위) new(매개변수 미존재)
    
    4순위) x++, x—
    
    5순위) !x, +x, -x, ++x, —x, typeof, delete
    
    6순위) **(이항연산자 중에서 우선순위가 가장 높다)
    
    7순위) *, /, %
    
    8순위) +, -
    
    9순위) <, < =, >, > =, in, instanceof
    
    10순위) ==, ! =, ===, ! ==
    
    11순위) ??(null 병합 연산자)
    
    12순위) &&
    
    13순위) ||
    
    14순위) ? …: … (삼항 연산자)
    
    15순위) 할당 연산자(=, +=, -=, …)
    
    16순위) ,
    
    팁
    
    - 다 기억하는 것은 힘듦
        
        → 우선순위가 가장 높은 그룹 연산자()를 사용해서 우선순위를 명시적으로 조절하자
        
    
## 7.13 연산자 결합 순서
    
    연산자의 어느 쪽(좌항 또는 우항)부터 평가를 수행할 것인지를 나타내는 순서
    
    `좌항 → 우항`: +, -, /, %, <, >, < =, > =, &&, ||, ., [], (), ??, ?., in, instanceof
    
    `우항 → 좌항`: ++, —, 할당연산자(=, +=, -=, …), !x, +x, -x, ++x, —x, typeof, delete, ? … : …(삼항 연산자)

  ---
    
# 8장. 제어문
    
    코드의 실행순서 인위적으로 제어 가능
    
## 8.1 블록문
    
    정의
    
    - 0개 이상의 문을 중괄호로 묶은 코드 블로 또는 블로
    - 블록문 하나가 자바스크립트에서는 실행단위
    - 블록문 끝엔 세미콜론(;)을 붙이지 않음(자체 종결성을 갖지 않음으로)
    
    종류
    
    ```jsx
    // 블록문
    {
    	var foo = 10;
    }
    
    // 제어문
    var x = 1;
    if(x < 10){
    	x++;
    }
    
    // 함수 선언문
    function sum(a, b){
    	return a+b;
    }
    ```
    
## 8.2 조건문
    
    정의
    
    - 주어진 조건식의 평가 결과에 따라 코드 불록의 실행을 결정
    - 조건식은 불리언 값으로 평가될 수 있음
    
    ### 8.2.1 if … else문
    
    - 조건이 한개인 경우( if / else)
        - true이면, if문을
        - false이면, else문을 실행
    - 조건이 2개 이상인 경우( if / else if / else)
        - 중간에 else if 문을 넣어서 조건식 추가 가능
        - else if는 여러번 사용가능(if와 else는 한번만 사용 가능)
    - else와 else if 문은 옵션이다 == 필수가 아니다
    - 삼항 연산자로 바꿔서 표현 가능(단순히 값을 결정하여 변수에 할당하는 경우 삼항 연산자가 더 가독성이 좋다. 여러줄이면 if else문이 가독성이 좋음)
    
### 8.2.2 switch 문
    
    정의
    
    - 일치하는 case문이 없다면 실행 순서는 default문으로 이동
    - default 문은 선택사항
    
    ```jsx
    switch(표현식) {
    	case 표현식 1:
    		// 표현식과 표현식 1이 일치하면 실행될 문
    		break;
    	case 표현식 2:
    		// 표현식과 표현식 2이 일치하면 실행될 문
    		break;
    	default:
    		// 표현식에 일치하는 case 문이 없을때,
    }
    ```
    
    - 폴스루(fall through)
        - case 문의 break문을 사용하지않으면, 그 아래 case까지 다 검사하다가 마지막 default에 걸려서 default를 수행하게 된다
        - 폴스루를 이용해서(= break 문을 쓰지 않아서) 더 유리하게도 사용가능
    - 지원하는 언어: C언어, 자바스크립트 / 지원하지 않는 언어: 파이썬
    - 조건문이 많을 경우 switch를 쓰면 가독성이 좋아지지만, 거의 if else 문을 씀
    
## 8.3 반복문
    
    조건식의 평가가 참인 경우 실행 + 조건식이 거짓일때까지 반복
    
    for 문/ while문 / do … while문
    
    <aside>
    ☝🏻 자바스크립트에서 반복문을 대체할 수 있는 기능
    - 배열 순회시 `forEach` 메서드
    - 객체의 프로퍼티를 열거할 때 사용하는 `for …in` 문
    - ES6에서 도입된 이터러블을 순회할 수 있는 `for … of` 문
    
    </aside>
    
    ### 8.3.1 for문
    
    ```jsx
    for (변수 선언문 또는 할당문; 조건식; 증감식) {
    	// 조건식이 참일 경우 반복 실행될 문;
    }
    ```
    
    - for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요 없다(단, 어떤 식도 선언하지 않으면 `무한루프`가 된다.)
        
        ```jsx
        for (;;) {
        	// 무한루프
        }
        ```
        
    - 중첩 for문으로 for문 안에 for문… 이런식으로 중첩으로 사용 가능
    
### 8.3.2 while문
    
    정의
    
    - 조건식의 평가가 참이면 코드 블록을 계속 반복 실행함
    - 조건식의 결과가 거짓이면 코드 블록을 실행하지 않고 종료
    - 만약, 조건식의 평가 결과 불리언 값이 아니면 불리언 값으로 강제 변화하여 논리적 참, 거짓을 구별
    
    for 문과의 차이
    
    - for 문은 반복횟수가 명확할 때 주로 사용
    - while 문은 반복 횟수가 불명확할 때 주로 사용
    
    조건식이 참인 경우 무한루프 → 무한루프 빠져나가기 위해선 if문을 사용해 break을 통해 빠져나간다
    
    ```jsx
    var count = 0;
    
    while(true) {
    	count ++;
    	if(count === 3) break;
    }
    ```
    
### 8.3.3 do .. while문
    
    정의
    
    - 코드 블록을 먼저 실행하고 조건식을 평가함( 즉, 코드 블록은 무조건 한번이상 실행됨)
    
## 8.4 break 문
    
    정의
    
    - 레이블 문, 반복문, switch 문의 코드 블록을 탈출함(이 외의 코드 블록에서 break문을 실행하면 문법에러SyntaxError가 발생함)
    
## 8.5 continue 문
    
    정의
    
    - continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킴(break 처럼 코드 블록을 탈출하지 않음)

---
    
# 9장. 타입 변환과 단축 평가

## 9.1 타입 변환이란?
    
    타입 변환의 종류
    
    - 명시적 타입 변환(타입 캐스팅): 개발자가 의도적으로 타입을 변환한 것
    - 암묵적 타입 변환(강제 타입 변환): 개발자의 의도와 상관없이 자바스크립트가 임의로 평가해 타입을 변환한 것
    
    정의
    
    - 기존 원시 값을 직접 변경하는 것이 아니라 기존 원시값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것
    - 암묵적 타입 변환은 기존 변수 값을 재할당 변경하는 것이 아니라, 자바스크립트는 표현식을 에러없이 평가하기 위해 한번 타입변환하고 바로 버린다
    
    코드를 예측할 수 있어야 함

## 9.2 암묵적 타입 변환

정의

- 개발자의 의도와 상관없이 코드의 문맥을 고려해 암묵적으로 코드 변환
- 가급적 에러를 발생하지 않도록 암묵적으로 타입을 변환하여 표현식을 평가함
- `문자열`, `숫자`, `불리언`과 같은 원시 타입 중 하나로 자동 변환됨.

### 9.2.1 문자열 타입으로 변환

```jsx
1+ '2' // "12"
```

- + 연산자는 하나이상이 문자열이면 문자열로 타입 변환해 계산함
- 연산자 표현식의 피연산자만이 암묵적 타입 변환의 대상이 되는 것이 아니다

### 9.2.2 숫자 타입으로 변환

- 산술연산자의 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야함
- 자바스크립트는 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 경우 피연산자를 숫자 타입으로 암묵적으로 변경함
- 0로 변환: 빈문자열(’ ’), 빈 배열([]), null, false
- 1로 변환: true

### 9.2.3 불리언 타입으로 변환

- 삼항 연산자에서 조건식의 평가 결과를 불리언 타입으로 암묵적으로 변환함
- 불리언 타입이 아닌 값을 Truthy(참으로 평가되는 값) 또는 Falsy(거짓으로 평가되는 값) 으로 구분함
    - Falsy 값에는 false, undefined,null, 0, -0, NaN, ‘ ‘(빈문자열)

## 9.3 명시적 타입 변환

정의

- 개발자의 의도에 따라 명시적으로 타입을 변경하는 방법
- 표준 빌트인인 생성자 함수 ex) 생성자 함수(String, Number, Boolean 등)를 new 연산자 없이 호출하는 방법
- 빌트인 메서드를 사용하는 방법
- 암묵적 타입 변환을 예측하고 이용하는 방법

### 9.3.1 문자열 타입으로 변환

방법

- String 생성자 함수를 new 연산자 없이 호출하는 방법
- Object.prototype.toString 메서드를 사용하는 방법
- 문자열 연결 연산자를 이용하는 방법

### 9.3.2 숫자 타입으로 변환

방법

- Number 생성자 함수를 new 연산자 없이 호출하는 방법
- parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)
- + 단항 산술 연산자를 이용하는 방법
- * 산술 연산자를 이용하는 방법

### 9.3.3 불리언 타입으로 변환

방법

- Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
- ! 부정 논리 연산자를 두 번 사용하는 방법

## 9.4 단축 평가

논리곱(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 2개의 피연산자 값 중 어느 한쪽으로 평가된다

### 9.4.1 논리 연산자를 사용한 단축 평가

```jsx
'Cat' && 'Dog' // "Dog" -> true && anything = anything

'Cat' || 'Dog' // 'Cat' -> (true)anything1 || anything2 = anything1
```

- 단축 평가
    - 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환
    - 표현식을 평가하는 도중 평가 결과가 확정된 경우 나머지 평가과정을 생략하는 것을 말함
    
    ```jsx
    true || anything // true
    false || anything // anything
    true && anything // anything
    false && anything // false
    ```
    
- 단축 평가가 유용하게 사용되는 상황
    - 상황1) 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조
        - 객체는 키와 값으로 구성된 프로퍼티의 집합
        - 객체를 가리키기를 기대하는 변수의 값이 객체가 아니라 null 또는 undefined인 경우 객체를 프로퍼티 참조하면 타입 에러 발생 → 프로그램 강제 종료된다
            
            → 단축 평가를 사용하면 에러 발생시키지 않음
            
        
    - 상황2) 함수 매개변수에 기본값을 설정할 때
        - 함수 호출시 인수를 전달하지 않으면 매개변수에는 undefined가 할당된다
        - 단축 평가를 사용해 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있음

### 9.4.2 옵셔널 체이닝 연산자

정의

- ES11에서 도입된 옵셔널 체이닝 연산자 .?
- 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고 그렇지 않은 경우 우항의 프로퍼티 참조를 이어간다 (객체를 가리키기를 기대하는 변수가 null 또는 undefined가 이닌지 확인하고 프로퍼티를 참조할 때 유용하다. )

논리 연산자 &&과의 차이

- &&
    - 좌항 피연산자가 false로 평가되는 Falsy값이면 좌항 연산자를 그대로 반환함
- 옵셔널 체이닝
    - 옵셔널 체이닝은 좌항 Falsy값이라더 null 또는 undefined가 아니면 우항의 프로퍼티 참조를 이어감

### 9.4.3 null 병합 연산자

정의

- ES11에서 도입된 null 병합연산자 ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환함

논리 연산자 || 과의 차이

- ||
    - 좌항의 피연산자가 Falsy 값이면 우항의 피연산자를 반환하는데, 만약 Falsy 값인 0이나 ‘ ‘도 기본값으로서 유효하다면 예기치 않은 동작이 발생할 수 있다
- null 병합 연산자
  - null 병합 연산자는 좌항 Falsy값이라더 null 또는 undefined가 아니면 우항의 프로퍼티 참조를 이어감
